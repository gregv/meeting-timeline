<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %></title>
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3J1YKM9S6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Y3J1YKM9S6');
  </script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.4.1/pixi.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.43/moment-timezone-with-data.min.js"></script>
  
  <!-- Analytics tracking utility -->
  <script src="/js/analytics.js"></script>
</head>
<body style="margin: 0; padding: 0; background-color: #<%= background %>; overflow: hidden;">

  <!-- Modern scroll-based zoom controls with auto-hide and dismiss -->
  <div id="zoomHelp" style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-family: monospace; font-size: 11px; opacity: 0.8; transition: opacity 1s ease-out; cursor: pointer;">
    üñ±Ô∏è Scroll to zoom ‚Ä¢ Double-click to reset ‚Ä¢ R to reset
    <span id="dismissHelp" style="margin-left: 8px; opacity: 0.6; font-size: 10px;">‚úï</span>
  </div>

  <div id="debug" style="position: fixed; top: 10px; left: 10px; z-index: 2000; background: rgba(0,0,0,0.9); color: white; padding: 10px; font-family: monospace; font-size: 11px; max-width: 400px; max-height: 300px; overflow-y: auto; border: 1px solid #333; border-radius: 4px; display: <%= config.showDebug ? 'block' : 'none' %>;">
    <div style="font-weight: bold; margin-bottom: 5px;">üêõ Debug Info:</div>
    <div id="debugContent" style="line-height: 1.2;"></div>
  </div>

  <script>
    // Server-side data passed to the client
    const meetingData = {
      title: "<%= title %>",
      start: "<%= start %>",
      background: "0x<%= background %>",
      movement_rate: <%= movement_rate %>,
      icon: "<%= icon %>",
      topics: <%- JSON.stringify(topics) %>,
      config: <%- JSON.stringify(config) %>
    };

    console.log("Raw meeting data:", meetingData);
    
    // Enhanced debug system - respects config setting
    const debugDiv = document.getElementById('debugContent');
    const debugContainer = document.getElementById('debug');
    const isDebugEnabled = meetingData.config.showDebug;
    
    function addDebug(text) {
      console.log('DEBUG:', text);
      if (debugDiv && isDebugEnabled) {
        debugDiv.innerHTML += text + '<br>';
        debugDiv.scrollTop = debugDiv.scrollHeight; // Auto-scroll to bottom
      }
    }
    
    if (isDebugEnabled) {
      addDebug('üöÄ Enhanced debug mode enabled');
    }
    
    addDebug(`Original start: ${meetingData.start}`);
    addDebug(`User timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`);
    
    // Parse the start time properly - server sends it as a Date string
    const startTime = moment(meetingData.start);
    addDebug(`Parsed start time: ${startTime.format('YYYY-MM-DD HH:mm:ss Z')}`);
    addDebug(`Current time: ${moment().format('YYYY-MM-DD HH:mm:ss Z')}`);
    
    // Calculate total duration and end time
    let totalDurationMinutes = 0;
    meetingData.topics.forEach(topic => {
      totalDurationMinutes += topic.time || 0;
    });
    
    const endTime = moment(startTime).add(totalDurationMinutes, 'minutes');
    addDebug(`Total duration: ${totalDurationMinutes} minutes`);
    addDebug(`Meeting end time: ${endTime.format('YYYY-MM-DD HH:mm:ss Z')}`);

    // Initialize PixiJS Application with proper sizing control
    (async () => {

      // Get actual viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      addDebug(`Viewport dimensions: ${viewportWidth}x${viewportHeight}`);

      // Create PixiJS application using modern initialization
      const app = new PIXI.Application();
      
      // Initialize the application with explicit dimensions (no auto-resize conflicts)
      await app.init({
        width: viewportWidth,
        height: viewportHeight,
        background: parseInt(meetingData.background),
        resolution: window.devicePixelRatio || 1
      });
      
      // Append the application canvas to the document body
      document.body.appendChild(app.canvas);
      
      // Force canvas to fill viewport (override any CSS issues)
      app.canvas.style.width = '100vw';
      app.canvas.style.height = '100vh';
      app.canvas.style.position = 'fixed';
      app.canvas.style.top = '0';
      app.canvas.style.left = '0';

      // Wait multiple frames to ensure everything is settled
      await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));

      // Verify final canvas dimensions
      const canvasWidth = app.screen.width;
      const canvasHeight = app.screen.height;
      
      addDebug(`Final canvas dimensions: ${canvasWidth}x${canvasHeight}`);
      addDebug(`Canvas element size: ${app.canvas.width}x${app.canvas.height}`);
      addDebug(`Canvas style size: ${app.canvas.style.width}x${app.canvas.style.height}`);

      // Create main timeline container
      const timeline = new PIXI.Container();
      app.stage.addChild(timeline);
      const nodeRadius = 10;
      const lineHeight = 4;
      const yPosition = canvasHeight / 2; // Center vertically in the viewport
      const startX = 50;
      const endX = canvasWidth - 100; // Leave more space on the right
      const timelineWidth = Math.max(100, endX - startX); // Ensure minimum width

      addDebug(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
      addDebug(`Timeline dimensions: ${startX} to ${endX} (width: ${timelineWidth})`);
      addDebug(`Timeline Y position: ${yPosition}`);

      // Draw base timeline with debug markers
      const baseTimeline = new PIXI.Graphics();
      baseTimeline.stroke({ width: lineHeight, color: 0xFFFFFF });
      baseTimeline.moveTo(startX, yPosition);
      baseTimeline.lineTo(endX, yPosition);
      timeline.addChild(baseTimeline);
      
      // Enhanced visual debug markers - respects config setting
      if (isDebugEnabled) {
        // Draw timeline boundary box
        const debugBounds = new PIXI.Graphics();
        debugBounds.stroke({ width: 2, color: 0xFF0000, alpha: 0.5 });
        debugBounds.rect(startX - 10, yPosition - 50, timelineWidth + 20, 100);
        timeline.addChild(debugBounds);
        
        // Draw center markers
        const centerMarker = new PIXI.Graphics();
        centerMarker.stroke({ width: 1, color: 0x00FF00 });
        centerMarker.moveTo(startX + timelineWidth/2, yPosition - 30);
        centerMarker.lineTo(startX + timelineWidth/2, yPosition + 30);
        timeline.addChild(centerMarker);
        
        // Draw canvas center marker
        const canvasCenterMarker = new PIXI.Graphics();
        canvasCenterMarker.stroke({ width: 2, color: 0x00FFFF });
        canvasCenterMarker.moveTo(0, canvasHeight/2 - 20);
        canvasCenterMarker.lineTo(canvasWidth, canvasHeight/2 - 20);
        canvasCenterMarker.moveTo(canvasWidth/2, 0);
        canvasCenterMarker.lineTo(canvasWidth/2, canvasHeight);
        app.stage.addChild(canvasCenterMarker);
        
        addDebug(`üéØ Enhanced debug markers added to timeline and canvas`);
      }

      // Create timeline segments for each topic with mission control aesthetics
      const segments = [];
      const segmentGlows = [];
      const labels = [];
      const timeLabels = [];
      const tooltips = [];
      const segmentData = []; // Store segment timing data
      let currentPosition = startX;
      let segmentStartTime = moment(startTime);

      // Dynamic Mission Control Color Scheme from configuration
      const colors = {
        completed: parseInt(meetingData.config.colors.completed, 16),
        current: parseInt(meetingData.config.colors.current, 16),
        upcoming: parseInt(meetingData.config.colors.upcoming, 16),
        completedAlpha: meetingData.config.colors.completedAlpha,
        currentAlpha: meetingData.config.colors.currentAlpha,
        upcomingAlpha: meetingData.config.colors.upcomingAlpha
      };

      addDebug(`Color scheme - Completed: #${meetingData.config.colors.completed}, Current: #${meetingData.config.colors.current}, Upcoming: #${meetingData.config.colors.upcoming}`);

      meetingData.topics.forEach((topic, index) => {
        addDebug(`Processing topic ${index}: ${topic.person} - ${topic.topic} (${topic.time}min)`);
        
        if (topic.topic && topic.topic.trim() !== "") { // Skip buffer/empty topics
          // Calculate segment width based on duration
          const segmentWidth = Math.max(50, (topic.time / totalDurationMinutes) * timelineWidth);
          const segmentHeight = meetingData.config.segmentHeight;
          const halfHeight = segmentHeight / 2;
          
          // Store segment timing data for state tracking
          const segmentEndTime = moment(segmentStartTime).add(topic.time, 'minutes');
          segmentData.push({
            startTime: moment(segmentStartTime),
            endTime: segmentEndTime,
            index: segments.length,
            topic: topic,
            width: segmentWidth,
            position: currentPosition
          });

          // Create segment rectangle with rounded corners and depth
          const segment = new PIXI.Graphics();
          segment.roundRect(0, -halfHeight, segmentWidth, segmentHeight, 8);
          segment.fill({ color: colors.upcoming, alpha: colors.upcomingAlpha });
          segment.stroke({ width: 2, color: 0xFFFFFF, alpha: 0.3 });
          segment.x = currentPosition;
          segment.y = yPosition;
          timeline.addChild(segment);
          segments.push(segment);

          // Create glow effect for current segment (initially hidden)
          const glow = new PIXI.Graphics();
          glow.roundRect(-5, -halfHeight - 5, segmentWidth + 10, segmentHeight + 10, 12);
          glow.fill({ color: colors.current, alpha: 0.0 });
          glow.x = currentPosition;
          glow.y = yPosition;
          timeline.addChild(glow);
          segmentGlows.push(glow);

          // Create status indicator (checkmark for completed, clock for current)
          let statusIcon = null;
          if (meetingData.config.showStatusIcons) {
            statusIcon = new PIXI.Text({
              text: '‚óã', // Circle for upcoming
              style: {
                fontSize: 16,
                fill: 0xFFFFFF,
                align: 'center'
              }
            });
            statusIcon.anchor.set(0.5);
            statusIcon.x = currentPosition + 20;
            statusIcon.y = yPosition;
            timeline.addChild(statusIcon);
          }
          segmentData[segmentData.length - 1].statusIcon = statusIcon;

          // Create topic label with configurable styling
          const label = new PIXI.Text({
            text: `${topic.person}: ${topic.topic}`,
            style: {
              fontSize: meetingData.config.blockFontSize,
              fill: 0xFFFFFF,
              align: 'center',
              wordWrap: true,
              wordWrapWidth: Math.max(segmentWidth - 40, 100),
              fontWeight: '500'
            }
          });
          label.anchor.set(0.5, 0);
          label.x = currentPosition + segmentWidth / 2;
          label.y = yPosition + halfHeight + 5;
          timeline.addChild(label);
          labels.push(label);

          // Create time label with configurable styling
          let timeLabel = null;
          if (meetingData.config.showTimeLabels) {
            timeLabel = new PIXI.Text({
              text: `${topic.time}min`,
              style: {
                fontSize: meetingData.config.timeLabelFontSize,
                fill: 0x00FF00, // Green like mission control
                align: 'center',
                fontFamily: 'monospace'
              }
            });
            timeLabel.anchor.set(0.5, 1);
            timeLabel.x = currentPosition + segmentWidth / 2;
            timeLabel.y = yPosition - halfHeight - 5;
            timeline.addChild(timeLabel);
          }
          timeLabels.push(timeLabel);

          // Create enhanced tooltip
          const tooltip = new PIXI.Text({
            text: `‚ñ∏ ${topic.person}\n‚ñ∏ ${topic.topic}\n‚ñ∏ Duration: ${topic.time} minutes\n‚ñ∏ Start: ${segmentStartTime.format('HH:mm')}\n‚ñ∏ End: ${segmentEndTime.format('HH:mm')}`,
            style: {
              fontSize: 11,
              fill: 0xFFFFFF,
              align: 'left',
              wordWrap: true,
              wordWrapWidth: 220,
              fontFamily: 'monospace',
              lineHeight: 16
            }
          });
          tooltip.anchor.set(0.5, 1);
          tooltip.x = currentPosition + segmentWidth / 2;
          tooltip.y = yPosition - 80;
          tooltip.visible = false;
          timeline.addChild(tooltip);
          tooltips.push(tooltip);

          // Add interactivity with better hover effects
          segment.eventMode = 'static';
          segment.cursor = 'pointer';
          segment.on('pointerover', () => {
            tooltip.visible = true;
          });
          segment.on('pointerout', () => {
            tooltip.visible = false;
          });

          currentPosition += segmentWidth + 10; // Larger gap for better separation
        } else {
          // For buffer/empty topics, just advance position proportionally
          const bufferWidth = (topic.time / totalDurationMinutes) * timelineWidth;
          currentPosition += bufferWidth;
        }

        segmentStartTime.add(topic.time, 'minutes');
      });

      addDebug(`Created ${segments.length} timeline segments`);

      // Create configurable current time marker
      const currentTimeMarker = new PIXI.Container();
      const markerConfig = meetingData.config.timeMarker;
      
      // Marker line (configurable)
      let markerLine = null;
      if (markerConfig.showLine) {
        markerLine = new PIXI.Graphics();
        const lineColor = parseInt(markerConfig.primaryColor, 16);
        const halfHeight = markerConfig.height / 2;
        
        markerLine.stroke({ width: markerConfig.lineWidth, color: lineColor });
        markerLine.moveTo(0, -halfHeight);
        markerLine.lineTo(0, halfHeight);
        currentTimeMarker.addChild(markerLine);
        
        // Add arrow or special styling based on marker style
        if (markerConfig.style === "arrow") {
          // Create arrow head
          const arrowSize = markerConfig.circleSize;
          markerLine.moveTo(-arrowSize, -halfHeight + arrowSize);
          markerLine.lineTo(0, -halfHeight);
          markerLine.lineTo(arrowSize, -halfHeight + arrowSize);
        }
      }

      // Marker circle (configurable)
      let markerCircle = null;
      if (markerConfig.showCircle) {
        markerCircle = new PIXI.Graphics();
        const circleColor = parseInt(markerConfig.primaryColor, 16);
        
        if (markerConfig.style === "modern") {
          markerCircle.circle(0, 0, markerConfig.circleSize);
          markerCircle.fill(circleColor);
        } else if (markerConfig.style === "classic") {
          markerCircle.circle(0, 0, markerConfig.circleSize);
          markerCircle.fill(circleColor);
          markerCircle.stroke({ width: 2, color: 0xFFFFFF });
        } else if (markerConfig.style === "minimal") {
          markerCircle.circle(0, 0, markerConfig.circleSize / 2);
          markerCircle.fill(circleColor);
        } else if (markerConfig.style === "arrow") {
          // Diamond shape for arrow style
          const size = markerConfig.circleSize;
          markerCircle.moveTo(0, -size);
          markerCircle.lineTo(size, 0);
          markerCircle.lineTo(0, size);
          markerCircle.lineTo(-size, 0);
          markerCircle.lineTo(0, -size);
          markerCircle.fill(circleColor);
        }
        
        currentTimeMarker.addChild(markerCircle);
      }

      // Glow effect (configurable)
      let glowEffect = null;
      if (markerConfig.showGlow && markerCircle) {
        glowEffect = new PIXI.Graphics();
        const glowColor = parseInt(markerConfig.secondaryColor, 16);
        const glowSize = markerConfig.circleSize * 3;
        
        glowEffect.circle(0, 0, glowSize);
        glowEffect.fill({ color: glowColor, alpha: 0 }); // Will be animated
        currentTimeMarker.addChildAt(glowEffect, 0); // Add behind other elements
      }

      // Create configurable time display
      const timeDisplay = new PIXI.Text({
        text: '',
        style: {
          fontSize: markerConfig.textStyle.fontSize,
          fill: parseInt(markerConfig.textStyle.color, 16),
          align: 'center',
          fontFamily: markerConfig.textStyle.fontFamily
        }
      });
      timeDisplay.anchor.set(0.5, 1);
      timeDisplay.y = -(markerConfig.height / 2) - 10;
      
      // Add text background if enabled
      if (markerConfig.textStyle.showBackground) {
        const textBg = new PIXI.Graphics();
        textBg.rect(-50, timeDisplay.y - markerConfig.textStyle.fontSize - 5, 100, markerConfig.textStyle.fontSize + 10);
        textBg.fill({ 
          color: parseInt(markerConfig.textStyle.backgroundColor, 16), 
          alpha: markerConfig.textStyle.backgroundAlpha 
        });
        currentTimeMarker.addChild(textBg);
      }
      
      currentTimeMarker.addChild(timeDisplay);

      currentTimeMarker.y = yPosition;
      timeline.addChild(currentTimeMarker);

      addDebug(`Time marker configured: ${markerConfig.style} style, ${markerConfig.primaryColor} primary, ${markerConfig.lineWidth}px line`);
      addDebug(`Precise positioning algorithm enabled - marker will sync with segment boundaries`);

      // Enhanced zoom and pan functionality with scroll-based zoom
      let isDragging = false;
      let dragStart = { x: 0, y: 0 };
      let currentScale = 1;

      // Calculate optimal initial scale to fit timeline with padding
      const optimalScale = Math.min(1, (canvasWidth - 200) / timelineWidth);
      currentScale = optimalScale;
      timeline.scale.set(currentScale);
      
      // Perfect centering - timeline centered both horizontally and vertically
      const centeredX = (canvasWidth - timelineWidth * currentScale) / 2;
      timeline.x = centeredX;
      timeline.y = 0; // Timeline elements are positioned relative to yPosition already

      addDebug(`=== TIMELINE POSITIONING DEBUG ===`);
      addDebug(`Canvas: ${canvasWidth}x${canvasHeight}`);
      addDebug(`Timeline width: ${timelineWidth} (from ${startX} to ${endX})`);
      addDebug(`Optimal scale: ${optimalScale.toFixed(3)}`);
      addDebug(`Scaled timeline width: ${(timelineWidth * currentScale).toFixed(1)}`);
      addDebug(`Available space: ${canvasWidth - 200}`);
      addDebug(`Centered X position: ${centeredX.toFixed(1)}`);
      addDebug(`Timeline final position: (${timeline.x.toFixed(1)}, ${timeline.y.toFixed(1)})`);
      addDebug(`Timeline Y position (center): ${yPosition}`);
      addDebug(`================================`);

      // Set up interactive stage for drag functionality
      app.stage.eventMode = 'static';
      app.stage.hitArea = app.screen;
      app.stage.on('pointerdown', onDragStart)
        .on('pointerup', onDragEnd)
        .on('pointerupoutside', onDragEnd)
        .on('pointermove', onDragMove);

      // Add scroll-based zoom functionality
      app.canvas.addEventListener('wheel', onWheel, { passive: false });

      function onDragStart(event) {
        isDragging = true;
        dragStart = { x: event.global.x - timeline.x, y: event.global.y - timeline.y };
      }

      function onDragEnd() {
        isDragging = false;
      }

      function onDragMove(event) {
        if (isDragging) {
          timeline.x = event.global.x - dragStart.x;
          timeline.y = event.global.y - dragStart.y;
        }
      }

      // Modern scroll-based zoom with smooth scaling
      function onWheel(event) {
        event.preventDefault();
        
        // Get mouse position relative to the canvas
        const rect = app.canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        
        // Determine zoom direction and factor
        const zoomIntensity = 0.1;
        const wheelDirection = event.deltaY > 0 ? -1 : 1; // Reverse for natural zoom feel
        const zoomFactor = 1 + (wheelDirection * zoomIntensity);
        
        // Calculate new scale with limits
        const newScale = Math.max(0.1, Math.min(5, currentScale * zoomFactor));
        
        if (newScale !== currentScale) {
          // Calculate the world position under the mouse
          const worldPos = {
            x: (mouseX - timeline.x) / currentScale,
            y: (mouseY - timeline.y) / currentScale
          };

          // Update scale
          currentScale = newScale;
          timeline.scale.set(currentScale);

          // Adjust position to keep mouse point fixed during zoom
          timeline.x = mouseX - worldPos.x * currentScale;
          timeline.y = mouseY - worldPos.y * currentScale;
          
          // Track zoom interaction for analytics
          if (window.analytics) {
            window.analytics.trackScrollZoom(wheelDirection > 0 ? 'in' : 'out', currentScale);
          }
          
          addDebug(`Scroll zoom: ${wheelDirection > 0 ? 'IN' : 'OUT'} to ${currentScale.toFixed(2)}x at mouse (${mouseX}, ${mouseY})`);
          
          // Show zoom level indicator temporarily (for UX feedback)
          if (zoomHelp) {
            const originalText = zoomHelp.textContent;
            zoomHelp.textContent = `üñ±Ô∏è Zoom: ${currentScale.toFixed(1)}x ‚Ä¢ Double-click to reset`;
            zoomHelp.style.opacity = '0.9';
            setTimeout(() => {
              zoomHelp.textContent = originalText;
              zoomHelp.style.opacity = '0.8';
            }, 1500);
          }
        }
      }

      // Double-click to reset to optimal view
      app.canvas.addEventListener('dblclick', resetToOptimalView);
      
      function resetToOptimalView() {
        const resetScale = Math.min(1, (canvasWidth - 200) / timelineWidth);
        currentScale = resetScale;
        timeline.scale.set(currentScale);
        
        // Re-center perfectly
        timeline.x = (canvasWidth - timelineWidth * currentScale) / 2;
        timeline.y = 0;
        
        // Track reset for analytics
        if (window.analytics) {
          window.analytics.trackZoomReset('double_click');
        }
        
        addDebug(`Double-click reset: Timeline reset to optimal view (${currentScale.toFixed(2)}x)`);
      }

      // Keyboard shortcuts for accessibility
      document.addEventListener('keydown', (event) => {
        if (event.code === 'KeyR' && !event.ctrlKey && !event.metaKey) {
          event.preventDefault();
          resetToOptimalView();
        }
      });

      // Auto-hide zoom help with dismiss functionality
      const zoomHelp = document.getElementById('zoomHelp');
      const dismissHelp = document.getElementById('dismissHelp');
      let helpTimeout;
      let isHelpDismissed = localStorage.getItem('zoomHelpDismissed') === 'true';
      
      function showZoomHelp() {
        if (zoomHelp && !isHelpDismissed) {
          zoomHelp.style.opacity = '0.8';
          clearTimeout(helpTimeout);
          helpTimeout = setTimeout(() => {
            zoomHelp.style.opacity = '0.3';
          }, 3000);
        }
      }
      
      function hideZoomHelp() {
        if (zoomHelp && !isHelpDismissed) {
          clearTimeout(helpTimeout);
          helpTimeout = setTimeout(() => {
            zoomHelp.style.opacity = '0.1';
          }, 5000);
        }
      }

      function dismissZoomHelp() {
        if (zoomHelp) {
          zoomHelp.style.opacity = '0';
          setTimeout(() => {
            zoomHelp.style.display = 'none';
          }, 1000);
          localStorage.setItem('zoomHelpDismissed', 'true');
          isHelpDismissed = true;
          
          // Track dismissal for analytics
          if (window.analytics) {
            window.analytics.trackFeatureUsage('zoom_help_dismissed');
          }
        }
      }

      // Set up dismiss functionality
      if (zoomHelp && dismissHelp) {
        // Click anywhere on help to dismiss
        zoomHelp.addEventListener('click', dismissZoomHelp);
        
        // Hover effects for better UX
        zoomHelp.addEventListener('mouseenter', () => {
          if (!isHelpDismissed) {
            dismissHelp.style.opacity = '1';
            zoomHelp.style.opacity = '0.9';
          }
        });
        
        zoomHelp.addEventListener('mouseleave', () => {
          if (!isHelpDismissed) {
            dismissHelp.style.opacity = '0.6';
          }
        });
      }

      // Show help on first interaction, then fade
      let hasInteracted = false;
      function onFirstInteraction() {
        if (!hasInteracted) {
          hasInteracted = true;
          showZoomHelp();
        }
      }

      // Initialize help visibility based on dismissal state
      if (isHelpDismissed) {
        if (zoomHelp) {
          zoomHelp.style.display = 'none';
        }
      } else {
        hideZoomHelp();
        
        // Show help when mouse enters canvas area
        if (app.canvas) {
          app.canvas.addEventListener('mouseenter', showZoomHelp);
          app.canvas.addEventListener('wheel', onFirstInteraction);
          app.canvas.addEventListener('dblclick', onFirstInteraction);
        }
      }

      // Enhanced animation loop with real-time segment state tracking
      let currentSegmentIndex = -1;
      let lastUpdateTime = 0;
      
      app.ticker.add((time) => {
        const now = moment();
        
        // Update time marker position with precise segment-based calculation
        if (now.isBefore(startTime)) {
          currentTimeMarker.x = startX;
          const timeToStart = moment.duration(startTime.diff(now));
          timeDisplay.text = `T-${timeToStart.humanize()}`;
        } else if (now.isAfter(endTime)) {
          currentTimeMarker.x = endX;
          timeDisplay.text = 'MISSION COMPLETE';
        } else {
          // Find the precise position based on actual segment timing and positions
          let markerX = startX;
          
          // Find which segment(s) we're in and calculate precise position
          for (let i = 0; i < segmentData.length; i++) {
            const segment = segmentData[i];
            
            if (now.isBefore(segment.startTime)) {
              // We're before this segment, position at the start of it
              markerX = segment.position;
              break;
            } else if (now.isBetween(segment.startTime, segment.endTime, null, '[]')) {
              // We're inside this segment, calculate position within it
              const segmentProgress = now.diff(segment.startTime) / segment.endTime.diff(segment.startTime);
              markerX = segment.position + (segmentProgress * segment.width);
              break;
            } else if (i === segmentData.length - 1) {
              // We're after the last segment
              markerX = segment.position + segment.width;
            } else if (now.isBefore(segmentData[i + 1].startTime)) {
              // We're in the gap between this segment and the next
              const nextSegment = segmentData[i + 1];
              const gapStart = segment.position + segment.width;
              const gapEnd = nextSegment.position;
              const gapProgress = now.diff(segment.endTime) / nextSegment.startTime.diff(segment.endTime);
              markerX = gapStart + (gapProgress * (gapEnd - gapStart));
              break;
            }
          }
          
          currentTimeMarker.x = markerX;
          timeDisplay.text = now.format('HH:mm:ss');
        }

        // Animate marker with mission control pulsing
        if (markerCircle) {
          markerCircle.alpha = 0.8 + Math.sin(Date.now() / 200) * 0.2;
        }
        
        // Update segment states based on current time (throttle to avoid excessive updates)
        if (Date.now() - lastUpdateTime > 1000) { // Update every second
          lastUpdateTime = Date.now();
          
          let newCurrentSegmentIndex = -1;
          
          // Find which segment we're currently in
          segmentData.forEach((segData, index) => {
            const isCompleted = now.isAfter(segData.endTime);
            const isCurrent = now.isBetween(segData.startTime, segData.endTime, null, '[]');
            const isUpcoming = now.isBefore(segData.startTime);
            
            if (isCurrent) {
              newCurrentSegmentIndex = index;
            }
            
            const segment = segments[segData.index];
            const glow = segmentGlows[segData.index];
            const label = labels[segData.index];
            const timeLabel = timeLabels[segData.index];
            const statusIcon = segData.statusIcon;
            
            if (isCompleted) {
              // Completed state - dark gray with checkmark
              segment.clear();
              segment.roundRect(0, -25, segData.width, 50, 8);
              segment.fill({ color: colors.completed, alpha: colors.completedAlpha });
              segment.stroke({ width: 2, color: 0x00FF00, alpha: 0.5 }); // Green border for completed
              
              glow.alpha = 0; // No glow for completed
              label.style.fill = 0xAAAAAA; // Muted text
              timeLabel.style.fill = 0x00AA00; // Dim green
              statusIcon.text = '‚úì';
              statusIcon.style.fill = 0x00FF00;
              
            } else if (isCurrent) {
              // Current state - bright amber with pulsing glow
              segment.clear();
              segment.roundRect(0, -25, segData.width, 50, 8);
              segment.fill({ color: colors.current, alpha: colors.currentAlpha });
              segment.stroke({ width: 3, color: 0xFFAA00, alpha: 0.8 }); // Bright orange border
              
              // Pulsing glow effect
              const glowAlpha = 0.2 + Math.sin(Date.now() / 400) * 0.15;
              glow.alpha = glowAlpha;
              
              label.style.fill = 0xFFFFFF; // Bright white text
              timeLabel.style.fill = 0xFFAA00; // Bright orange
              statusIcon.text = '‚ñ∂';
              statusIcon.style.fill = 0xFFAA00;
              
              // Calculate progress within current segment
              const segmentProgress = now.diff(segData.startTime) / segData.endTime.diff(segData.startTime);
              const progressBar = new PIXI.Graphics();
              progressBar.rect(0, 23, segData.width * segmentProgress, 2);
              progressBar.fill({ color: 0xFFAA00, alpha: 0.8 });
              progressBar.x = segData.position;
              progressBar.y = yPosition;
              
              // Remove old progress bar if exists
              if (segData.progressBar) {
                timeline.removeChild(segData.progressBar);
              }
              timeline.addChild(progressBar);
              segData.progressBar = progressBar;
              
            } else if (isUpcoming) {
              // Upcoming state - cool blue
              segment.clear();
              segment.roundRect(0, -25, segData.width, 50, 8);
              segment.fill({ color: colors.upcoming, alpha: colors.upcomingAlpha });
              segment.stroke({ width: 2, color: 0x0099CC, alpha: 0.6 });
              
              glow.alpha = 0; // No glow for upcoming
              label.style.fill = 0xCCCCCC; // Slightly muted text
              timeLabel.style.fill = 0x0099CC; // Blue
              statusIcon.text = '‚óã';
              statusIcon.style.fill = 0x0099CC;
              
              // Remove progress bar if segment is no longer current
              if (segData.progressBar) {
                timeline.removeChild(segData.progressBar);
                segData.progressBar = null;
              }
            }
          });
          
          // Update current segment tracking
          if (newCurrentSegmentIndex !== currentSegmentIndex) {
            currentSegmentIndex = newCurrentSegmentIndex;
            if (currentSegmentIndex >= 0) {
              const currentSeg = segmentData[currentSegmentIndex];
              addDebug(`Now in segment: ${currentSeg.topic.person} - ${currentSeg.topic.topic}`);
            }
          }
        }
      });

      // Title display with configurable styling
      const titleText = new PIXI.Text({
        text: meetingData.title,
        style: {
          fontSize: meetingData.config.titleFontSize,
          fill: 0xFFFFFF,
          align: 'center',
          fontWeight: 'bold'
        }
      });
      titleText.anchor.set(0.5, 0);
      titleText.x = canvasWidth / 2;
      titleText.y = 15;
      app.stage.addChild(titleText);
      
      addDebug(`üìù Title positioned at: (${titleText.x}, ${titleText.y}) with canvas width: ${canvasWidth}`);

      // Mission status display (bottom right)
      const statusDisplay = new PIXI.Text({
        text: 'MISSION STATUS: STANDBY',
        style: {
          fontSize: 12,
          fill: 0x00FF00,
          align: 'right',
          fontFamily: 'monospace'
        }
      });
      statusDisplay.anchor.set(1, 1);
      statusDisplay.x = canvasWidth - 20;
      statusDisplay.y = canvasHeight - 20;
      app.stage.addChild(statusDisplay);

      // Current segment info display (top center)
      const currentSegmentDisplay = new PIXI.Text({
        text: '',
        style: {
          fontSize: 14,
          fill: 0xFFAA00,
          align: 'center',
          fontFamily: 'monospace'
        }
      });
      currentSegmentDisplay.anchor.set(0.5, 0);
      currentSegmentDisplay.x = canvasWidth / 2;
      currentSegmentDisplay.y = 50;
      app.stage.addChild(currentSegmentDisplay);

      // Main animation loop with enhanced mission control features
      app.ticker.add((time) => {
        const now = moment();
        
        // Update time marker position with precise segment-based calculation
        if (now.isBefore(startTime)) {
          currentTimeMarker.x = startX;
          const timeToStart = moment.duration(startTime.diff(now));
          timeDisplay.text = `T-${timeToStart.humanize()}`;
          statusDisplay.text = 'MISSION STATUS: PRE-FLIGHT';
          statusDisplay.style.fill = 0x0099CC;
          currentSegmentDisplay.text = `LAUNCHING IN ${timeToStart.humanize().toUpperCase()}`;
        } else if (now.isAfter(endTime)) {
          currentTimeMarker.x = endX;
          timeDisplay.text = 'MISSION COMPLETE';
          statusDisplay.text = 'MISSION STATUS: COMPLETE';
          statusDisplay.style.fill = 0x00FF00;
          currentSegmentDisplay.text = 'ALL OBJECTIVES ACHIEVED';
        } else {
          // Find the precise position based on actual segment timing and positions
          let markerX = startX;
          
          // Find which segment(s) we're in and calculate precise position
          for (let i = 0; i < segmentData.length; i++) {
            const segment = segmentData[i];
            
            if (now.isBefore(segment.startTime)) {
              // We're before this segment, position at the start of it
              markerX = segment.position;
              break;
            } else if (now.isBetween(segment.startTime, segment.endTime, null, '[]')) {
              // We're inside this segment, calculate position within it
              const segmentProgress = now.diff(segment.startTime) / segment.endTime.diff(segment.startTime);
              markerX = segment.position + (segmentProgress * segment.width);
              break;
            } else if (i === segmentData.length - 1) {
              // We're after the last segment
              markerX = segment.position + segment.width;
            } else if (now.isBefore(segmentData[i + 1].startTime)) {
              // We're in the gap between this segment and the next
              const nextSegment = segmentData[i + 1];
              const gapStart = segment.position + segment.width;
              const gapEnd = nextSegment.position;
              const gapProgress = now.diff(segment.endTime) / nextSegment.startTime.diff(segment.endTime);
              markerX = gapStart + (gapProgress * (gapEnd - gapStart));
              break;
            }
          }
          
          currentTimeMarker.x = markerX;
          timeDisplay.text = now.format('HH:mm:ss');
          statusDisplay.text = 'MISSION STATUS: ACTIVE';
          statusDisplay.style.fill = 0xFFAA00;
        }

        // Animate marker with configurable pulsing
        if (markerCircle) {
          markerCircle.alpha = 0.8 + Math.sin(Date.now() / markerConfig.pulseSpeed) * 0.2;
        }
        
        // Animate glow effect if enabled
        if (glowEffect) {
          const glowAlpha = markerConfig.glowIntensity + Math.sin(Date.now() / (markerConfig.pulseSpeed * 1.5)) * (markerConfig.glowIntensity * 0.5);
          glowEffect.alpha = glowAlpha;
        }
        
        // Update segment states based on current time (throttle to avoid excessive updates)
        if (Date.now() - lastUpdateTime > 1000) { // Update every second
          lastUpdateTime = Date.now();
          
          let newCurrentSegmentIndex = -1;
          
          // Find which segment we're currently in
          segmentData.forEach((segData, index) => {
            const isCompleted = now.isAfter(segData.endTime);
            const isCurrent = now.isBetween(segData.startTime, segData.endTime, null, '[]');
            const isUpcoming = now.isBefore(segData.startTime);
            
            if (isCurrent) {
              newCurrentSegmentIndex = index;
            }
            
            const segment = segments[segData.index];
            const glow = segmentGlows[segData.index];
            const label = labels[segData.index];
            const timeLabel = timeLabels[segData.index];
            const statusIcon = segData.statusIcon;
            
            const segmentHeight = meetingData.config.segmentHeight;
            const halfHeight = segmentHeight / 2;
            
            if (isCompleted) {
              // Completed state - dark gray with checkmark
              segment.clear();
              segment.roundRect(0, -halfHeight, segData.width, segmentHeight, 8);
              segment.fill({ color: colors.completed, alpha: colors.completedAlpha });
              segment.stroke({ width: 2, color: 0x00FF00, alpha: 0.5 }); // Green border for completed
              
              glow.alpha = 0; // No glow for completed
              label.style.fill = 0xAAAAAA; // Muted text
              if (timeLabel) timeLabel.style.fill = 0x00AA00; // Dim green
              if (statusIcon) {
                statusIcon.text = '‚úì';
                statusIcon.style.fill = 0x00FF00;
              }
              
            } else if (isCurrent) {
              // Current state - bright amber with pulsing glow
              segment.clear();
              segment.roundRect(0, -halfHeight, segData.width, segmentHeight, 8);
              segment.fill({ color: colors.current, alpha: colors.currentAlpha });
              segment.stroke({ width: 3, color: 0xFFAA00, alpha: 0.8 }); // Bright orange border
              
              // Pulsing glow effect
              const glowAlpha = 0.2 + Math.sin(Date.now() / (400 / meetingData.config.animationSpeed)) * 0.15;
              glow.alpha = glowAlpha;
              
              label.style.fill = 0xFFFFFF; // Bright white text
              if (timeLabel) timeLabel.style.fill = 0xFFAA00; // Bright orange
              if (statusIcon) {
                statusIcon.text = '‚ñ∂';
                statusIcon.style.fill = 0xFFAA00;
              }
              
              // Progress bar (configurable)
              if (meetingData.config.showProgressBars) {
                const segmentProgress = now.diff(segData.startTime) / segData.endTime.diff(segData.startTime);
                const progressBar = new PIXI.Graphics();
                progressBar.rect(0, halfHeight - 2, segData.width * segmentProgress, 2);
                progressBar.fill({ color: 0xFFAA00, alpha: 0.8 });
                progressBar.x = segData.position;
                progressBar.y = yPosition;
                
                // Remove old progress bar if exists
                if (segData.progressBar) {
                  timeline.removeChild(segData.progressBar);
                }
                timeline.addChild(progressBar);
                segData.progressBar = progressBar;
              }
              
              // Update current segment display
              const timeRemaining = moment.duration(segData.endTime.diff(now));
              currentSegmentDisplay.text = `CURRENT: ${segData.topic.person.toUpperCase()} | ${timeRemaining.minutes()}:${timeRemaining.seconds().toString().padStart(2, '0')} REMAINING`;
              
            } else if (isUpcoming) {
              // Upcoming state - cool blue
              segment.clear();
              segment.roundRect(0, -halfHeight, segData.width, segmentHeight, 8);
              segment.fill({ color: colors.upcoming, alpha: colors.upcomingAlpha });
              segment.stroke({ width: 2, color: 0x0099CC, alpha: 0.6 });
              
              glow.alpha = 0; // No glow for upcoming
              label.style.fill = 0xCCCCCC; // Slightly muted text
              if (timeLabel) timeLabel.style.fill = 0x0099CC; // Blue
              if (statusIcon) {
                statusIcon.text = '‚óã';
                statusIcon.style.fill = 0x0099CC;
              }
              
              // Remove progress bar if segment is no longer current
              if (segData.progressBar) {
                timeline.removeChild(segData.progressBar);
                segData.progressBar = null;
              }
            }
          });
          
          // Update current segment tracking
          if (newCurrentSegmentIndex !== currentSegmentIndex) {
            currentSegmentIndex = newCurrentSegmentIndex;
            if (currentSegmentIndex >= 0) {
              const currentSeg = segmentData[currentSegmentIndex];
              addDebug(`üéØ ACTIVE: ${currentSeg.topic.person} - ${currentSeg.topic.topic}`);
            } else if (now.isAfter(endTime)) {
              currentSegmentDisplay.text = 'MISSION ACCOMPLISHED';
              addDebug(`‚úÖ MISSION COMPLETE`);
            } else {
              currentSegmentDisplay.text = 'MISSION STANDBY';
            }
          }
        }
      });

    })().catch(console.error);
    
    // Analytics tracking for meeting view and timeline interactions
    (function() {
      // Track meeting viewed
      if (window.analytics) {
        const meetingViewData = {
          id: meetingData.title || window.location.pathname.split('/').pop(),
          topics: meetingData.topics,
          duration: totalDurationMinutes,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          background: meetingData.background
        };
        
        // Track meeting pattern analysis
        window.analytics.trackMeetingViewed(meetingViewData);
        window.analytics.trackMeetingPurposePattern(meetingData.topics);
      }
      
      // Track modern timeline control interactions
      let timelineStarted = false;
      let zoomInteractionCount = 0;
      
      const trackTimelineStart = () => {
        if (!timelineStarted && window.analytics) {
          timelineStarted = true;
          window.analytics.trackTimelineStarted();
        }
      };
      
      // Track scroll zoom interactions (called from onWheel function above)
      // Note: trackScrollZoom is called directly in the onWheel function
      
      // Track double-click reset interactions (called from resetToOptimalView function above) 
      // Note: trackZoomReset is called directly in the resetToOptimalView function
      
      // Track keyboard shortcuts
      document.addEventListener('keydown', (event) => {
        if (event.code === 'KeyR' && !event.ctrlKey && !event.metaKey && window.analytics) {
          window.analytics.trackKeyboardShortcut('reset_view');
          trackTimelineStart();
        }
      });
      
      // Track timeline completion when meeting ends
      const checkTimelineCompletion = () => {
        const now = moment();
        const endTime = moment(startTime).add(totalDurationMinutes, 'minutes');
        
        if (now.isAfter(endTime) && timelineStarted && window.analytics) {
          window.analytics.trackTimelineCompleted(totalDurationMinutes);
          clearInterval(completionCheckInterval); // Stop checking
        }
      };
      
      // Check for completion every 30 seconds
      const completionCheckInterval = setInterval(checkTimelineCompletion, 30000);
      
      // Check for any stored meeting creation data from form submission
      if (sessionStorage.getItem('newMeetingData') && window.analytics) {
        try {
          const newMeetingData = JSON.parse(sessionStorage.getItem('newMeetingData'));
          window.analytics.trackMeetingCreated(newMeetingData);
          sessionStorage.removeItem('newMeetingData'); // Clean up
        } catch (e) {
          console.warn('Could not parse stored meeting data:', e);
        }
      }
      
      // Track performance metrics
      if (window.analytics && window.performance) {
        // Track page load time
        window.addEventListener('load', () => {
          setTimeout(() => {
            const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
            window.analytics.trackPerformance('page_load_time', loadTime);
          }, 0);
        });
        
        // Track PixiJS initialization performance
        const pixiInitTime = performance.now();
        setTimeout(() => {
          const pixiLoadTime = performance.now() - pixiInitTime;
          if (window.analytics) {
            window.analytics.trackPerformance('pixi_init_time', pixiLoadTime);
          }
        }, 1000);
      }
      
      // Track any errors
      window.addEventListener('error', (e) => {
        if (window.analytics) {
          window.analytics.trackError('javascript_error', e.message, {
            filename: e.filename,
            lineno: e.lineno,
            colno: e.colno
          });
        }
      });
      
      // Track feature usage based on timeline interactions
      let dragInteractionCount = 0;
      if (timeline) {
        timeline.on('pointermove', () => {
          dragInteractionCount++;
          if (window.analytics && dragInteractionCount % 10 === 0) {
            window.analytics.trackTimelineDrag();
          }
        });
      }
      
    })();

  </script>
</body>
</html>